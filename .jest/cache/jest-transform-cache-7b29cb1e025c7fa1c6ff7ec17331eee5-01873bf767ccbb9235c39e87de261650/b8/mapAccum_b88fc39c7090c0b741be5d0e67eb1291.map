{"version":3,"sources":["mapAccum.js"],"names":["_curry3","require","mapAccum","fn","acc","list","idx","len","length","result","tuple","module","exports"],"mappings":"AAAA,IAAIA,OAAO,GAEXC,OAAO,CAAC,oBAAD,CAFP;;AAuCA,IAAIC,QAAQ,GAEZF,OAAO,CAAC,SAASE,QAAT,CAAkBC,EAAlB,EAAsBC,GAAtB,EAA2BC,IAA3B,EAAiC;AACvC,MAAIC,GAAG,GAAG,CAAV;AACA,MAAIC,GAAG,GAAGF,IAAI,CAACG,MAAf;AACA,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIC,KAAK,GAAG,CAACN,GAAD,CAAZ;;AAEA,SAAOE,GAAG,GAAGC,GAAb,EAAkB;AAChBG,IAAAA,KAAK,GAAGP,EAAE,CAACO,KAAK,CAAC,CAAD,CAAN,EAAWL,IAAI,CAACC,GAAD,CAAf,CAAV;AACAG,IAAAA,MAAM,CAACH,GAAD,CAAN,GAAcI,KAAK,CAAC,CAAD,CAAnB;AACAJ,IAAAA,GAAG,IAAI,CAAP;AACD;;AAED,SAAO,CAACI,KAAK,CAAC,CAAD,CAAN,EAAWD,MAAX,CAAP;AACD,CAbM,CAFP;;AAiBAE,MAAM,CAACC,OAAP,GAAiBV,QAAjB","sourcesContent":["var _curry3 =\n/*#__PURE__*/\nrequire(\"./internal/_curry3\");\n/**\n * The `mapAccum` function behaves like a combination of map and reduce; it\n * applies a function to each element of a list, passing an accumulating\n * parameter from left to right, and returning a final value of this\n * accumulator together with the new list.\n *\n * The iterator function receives two arguments, *acc* and *value*, and should\n * return a tuple *[acc, value]*.\n *\n * @func\n * @memberOf R\n * @since v0.10.0\n * @category List\n * @sig ((acc, x) -> (acc, y)) -> acc -> [x] -> (acc, [y])\n * @param {Function} fn The function to be called on every element of the input `list`.\n * @param {*} acc The accumulator value.\n * @param {Array} list The list to iterate over.\n * @return {*} The final, accumulated value.\n * @see R.scan, R.addIndex, R.mapAccumRight\n * @example\n *\n *      const digits = ['1', '2', '3', '4'];\n *      const appender = (a, b) => [a + b, a + b];\n *\n *      R.mapAccum(appender, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]\n * @symb R.mapAccum(f, a, [b, c, d]) = [\n *   f(f(f(a, b)[0], c)[0], d)[0],\n *   [\n *     f(a, b)[1],\n *     f(f(a, b)[0], c)[1],\n *     f(f(f(a, b)[0], c)[0], d)[1]\n *   ]\n * ]\n */\n\n\nvar mapAccum =\n/*#__PURE__*/\n_curry3(function mapAccum(fn, acc, list) {\n  var idx = 0;\n  var len = list.length;\n  var result = [];\n  var tuple = [acc];\n\n  while (idx < len) {\n    tuple = fn(tuple[0], list[idx]);\n    result[idx] = tuple[1];\n    idx += 1;\n  }\n\n  return [tuple[0], result];\n});\n\nmodule.exports = mapAccum;"]}