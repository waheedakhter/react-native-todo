{"version":3,"sources":["Y.js"],"names":["exports","__esModule","_ramda","require","Y","curryN","le","f","g","x","_default"],"mappings":"AAAA;;AAEAA,OAAO,CAACC,UAAR,GAAqB,IAArB;AACAD,OAAO,CAAC,SAAD,CAAP,GAAqB,KAAK,CAA1B;;AAEA,IAAIE,MAAM,GAAGC,OAAO,CAAC,OAAD,CAApB;;AA4BA,IAAIC,CAAC,GAAG,CAAC,GAAGF,MAAM,CAACG,MAAX,EAAmB,CAAnB,EAAsB,UAAUC,EAAV,EAAc;AAC1C,SAAO,UAAUC,CAAV,EAAa;AAClB,WAAOA,CAAC,CAACA,CAAD,CAAR;AACD,GAFM,CAEL,UAAUC,CAAV,EAAa;AACb,WAAOF,EAAE,CAAC,UAAUG,CAAV,EAAa;AACrB,aAAOD,CAAC,CAACA,CAAD,CAAD,CAAKC,CAAL,CAAP;AACD,KAFQ,CAAT;AAGD,GANM,CAAP;AAOD,CARO,CAAR;AASA,IAAIC,QAAQ,GAAGN,CAAf;AACAJ,OAAO,CAAC,SAAD,CAAP,GAAqBU,QAArB","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _ramda = require(\"ramda\");\n\n/**\n * Y-combinator\n *\n * The Y combinator is an interesting function which only works with functional languages,\n * showing how recursion can still be done even without any variable or function declarations,\n * only functions and parameters\n *\n * @func Y\n * @memberOf RA\n * @since {@link https://char0n.github.io/ramda-adjunct/2.3.0|v2.3.0}\n * @category Function\n * @sig (a, ... -> b -> b) -> (a, ... -> b)\n * @param {Function} le Recursive function maker\n * @return {Function}\n * @see {@link http://kestas.kuliukas.com/YCombinatorExplained/|Y combinator explained}\n * @example\n *\n * const makeFact = givenFact => (n) => {\n *   if (n < 2) { return 1 }\n *   return n * givenFact(n - 1);\n * };\n *\n * const factorial = RA.Y(makeFact);\n *\n * factorial(5); //=> 120\n */\nvar Y = (0, _ramda.curryN)(1, function (le) {\n  return function (f) {\n    return f(f);\n  }(function (g) {\n    return le(function (x) {\n      return g(g)(x);\n    });\n  });\n});\nvar _default = Y;\nexports[\"default\"] = _default;"]}