{"version":3,"sources":["index.ts"],"names":["runTiming","clock","value","dest","onFinish","config","duration","toValue","Value","easing","Easing","inOut","ease","state","finished","position","time","frameTime"],"mappings":";;;;;;;;;AAAA;;AAEO,IAAMA,SAAS,GAAG,SAAZA,SAAY,CACvBC,KADuB,EAEvBC,KAFuB,EAGvBC,IAHuB,EAIvBC,QAJuB,EAUpB;AAAA,MALHC,MAKG,uEALM;AACPC,IAAAA,QAAQ,EAAE,GADH;AAEPC,IAAAA,OAAO,EAAE,IAAIC,4BAAJ,CAAU,CAAV,CAFF;AAGPC,IAAAA,MAAM,EAAEC,8BAAOC,KAAP,CAAaD,8BAAOE,IAApB;AAHD,GAKN;AACH,MAAMC,KAAK,GAAG;AACZC,IAAAA,QAAQ,EAAE,IAAIN,4BAAJ,CAAU,CAAV,CADE;AAEZO,IAAAA,QAAQ,EAAE,IAAIP,4BAAJ,CAAU,CAAV,CAFE;AAGZQ,IAAAA,IAAI,EAAE,IAAIR,4BAAJ,CAAU,CAAV,CAHM;AAIZS,IAAAA,SAAS,EAAE,IAAIT,4BAAJ,CAAU,CAAV;AAJC,GAAd;AAMA,SAAO,kCAAM,CACX,iCACE,yCAAaP,KAAb,CADF,EAEE,CAEE,gCAAII,MAAM,CAACE,OAAX,EAAoBJ,IAApB,CAFF,CAFF,EAME,CAEE,gCAAIU,KAAK,CAACC,QAAV,EAAoB,CAApB,CAFF,EAGE,gCAAID,KAAK,CAACG,IAAV,EAAgB,CAAhB,CAHF,EAIE,gCAAIH,KAAK,CAACE,QAAV,EAAoBb,KAApB,CAJF,EAKE,gCAAIW,KAAK,CAACI,SAAV,EAAqB,CAArB,CALF,EAME,gCAAIZ,MAAM,CAACE,OAAX,EAAoBJ,IAApB,CANF,EAOE,uCAAWF,KAAX,CAPF,CANF,CADW,EAkBX,mCAAOA,KAAP,EAAcY,KAAd,EAAqBR,MAArB,CAlBW,EAoBX,iCACEQ,KAAK,CAACC,QADR,EAEE,kCAAM,CACJ,sCAAUb,KAAV,CADI,EAEJ,iCAAK,CAACY,KAAK,CAACC,QAAP,CAAL,EAAuB,gBAAgB;AAAA;AAAA,QAAdA,QAAc;;AACrC,QAAIA,QAAJ,EAAc;AACZV,MAAAA,QAAQ,QAAR,YAAAA,QAAQ;AACR,sCAAIS,KAAK,CAACC,QAAV,EAAoB,CAApB;AACD;AACF,GALD,CAFI,CAAN,CAFF,CApBW,EAiCXD,KAAK,CAACE,QAjCK,CAAN,CAAP;AAmCD,CApDM","sourcesContent":["import { AnimatedClock, AnimatedNode, block, call, clockRunning, cond, Easing, set, startClock, stopClock, timing, Value } from \"react-native-reanimated\";\n\nexport const runTiming = (\n  clock: AnimatedClock,\n  value: AnimatedNode,\n  dest: typeof AnimatedNode,\n  onFinish?: () => void,\n  config = {\n    duration: 100,\n    toValue: new Value(0),\n    easing: Easing.inOut(Easing.ease),\n  },\n) => {\n  const state = {\n    finished: new Value(0),\n    position: new Value(0),\n    time: new Value(0),\n    frameTime: new Value(0),\n  };\n  return block([\n    cond(\n      clockRunning(clock),\n      [\n        // if the clock is already running we update the toValue, in case a new dest has been passed in\n        set(config.toValue, dest),\n      ],\n      [\n        // if the clock isn't running we reset all the animation params and start the clock\n        set(state.finished, 0),\n        set(state.time, 0),\n        set(state.position, value),\n        set(state.frameTime, 0),\n        set(config.toValue, dest),\n        startClock(clock),\n      ],\n    ),\n    // we run the step here that is going to update position\n    timing(clock, state, config),\n    // if the animation is over we stop the clock\n    cond(\n      state.finished,\n      block([\n        stopClock(clock),\n        call([state.finished], ([finished]) => {\n          if (finished) {\n            onFinish?.();\n            set(state.finished, 0);\n          }\n        }),\n      ]),\n    ),\n    // we made the block return the updated position\n    state.position,\n  ]);\n};\n"]}